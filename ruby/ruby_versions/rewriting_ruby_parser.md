# Ruby parser 재작성
현재 CRuby 파서에는 우리가 해결하고자 하는 몇 가지 오래된 문제가 있다. 대체로 이들은 유지 보수성, 오류 허용, 이식성 및 성능의 네 가지 범주로 나뉜다.

# 동기
## 1. 유지 보수성
- 현재 CRuby 파서 문서 존재하지 않음
- 복잡한 구조로 인해 기여도도 적음
    - 두 달전 나온 버그(https://bugs.ruby-lang.org/issues/19392)도 복잡한 구조로 인해 변경 어려움

## 2. 오차 허용
오류 허용 오차는 구문 오류가 발생하더라도 프로그램 구문 분석을 계속하는 구문 분석기의 기능이다. 즉, 오류 허용 파서는 구문 오류가 있는 경우에도 여전히 구문 트리를 생성할 수 있다.

오류 허용 오차는 여러가지로 중요하다. Editor, Sorbet이나 steep과 같은 타입 체커, language server는 파서에 의존하여 편집 또는 분석중인 코드에 대한 정확한 메타데이터를 제공한다.

예를 들어 편집기가 한 번에 하나의 오류만 표시할 수 있는지 생각해 보자. 하나가 수정될 때마다 다음이 나타난다. 이는 개발자에게 시간이 많이 걸리고 좌절감을 줄 수 있다. 다음 스니펫을 고려해보자.

``` ruby
class Foo
  def initialize(a: 1, b = 2)
    true &&
  end
```

ruby -c 하면 다음과 같은 결과를 얻는다.
```
asg.rb:2: syntax error, unexpected local variable or method (SyntaxError)
  def initialize(a: 1, b = 2)
                       ^
asg.rb:4: syntax error, unexpected `end'
  end
  ^~~
```

## 3. 이식성
이식성은 CRuby 코드베이스 외부에서 파서를 사용할 수 있는 능력을 의미한다. 현재 파서는 CRuby 코드베이스에서만 사용할 수 있는 데이터 구조와 기능이 CRuby 내부에 밀접하게 연결되어 있다. 이로 인해 다른 툴링에서 사용할 수 없다.

따라서 커뮤니티는 각자 솔루션을 개발했다.
- CRuby
- mRuby
- JRuby
- TruffleRuby
- ...

새 구문이 Ruby에 도입될 때마다 모든 파서가 업데이트되어야 한다. 휴대성은 구문 트리의 유용성과도 연관있다. Parser에서 구문 트리를 추출할 수 있더라도 구문 트리가 런타임에 너무 밀접하게 연결되어 있으면 이식성이 없다.


## 4. 성능
수년에 걸쳐 프로세서와 C 컴파일러는 몇 가지 기술을 사용하여 훨씬 더 좋아졌다. 여기에는 파이프라이닝, 인라인 함수 및 분기 예측이 포함된다.

그런데 불행하게도 대부분의 파서 생성기에 의해 생성된 파서는 이러한 기술을 적용하기 어렵게 만든다. 대부분의 생성된 파서는 Jump 테이블과 gotos의 조합으로 작동하여 일부 고급 최적화 기술을 무력하게 만든다. 이로 인해 생성된 파서에는 상당한 노력 없이는 극복하기 매우 어려운 최대 성능 절벽이 있다.


# 개발
## 1. 설계
https://docs.google.com/document/d/1x74L_paTxS_h8_OtQjDoLVgxZP6Y96WOJ1LdLNb4BKM/edit#heading=h.6eyajfy04xhw
처음에 저희는 프로젝트에 대한 디자인 문서를 만들었는데, 지금도 찾아볼 수 있다. 이 문서를 내부적으로 공유한 후 Matz와 CRuby 팀은 물론 JRuby, TruffleRuby 및 가능한 한 많은 툴링 보석(특히 파서 및 irb 포함)의 유지 관리자와도 논의했다.

이러한 논의에서 나온 몇 가지 중요한 디자인 결정 사항은 다음과 같다. Matz와 CRuby 팀이 디자인에 만족하고 접근 방식에 동의한 후, 준비가 되면 YARP를 병합하기로 결정하자 본격적인 작업이 시작되었다.

## 2. 언어
구현 언어에 대한 활발한 토론이 있었지만 결국 C로 결정했다. 다른 옵션으로는 다양한 interop 옵션(WASM cross-compilation 포함)이 있는 C++와 Rust도 고려했습니다. 결국 두 가지 설득력 있는 이유로 결정이 내려졌다.

첫 번째는 기술적 이유이다. 구문 분석기는 C 컴파일러가 있는 모든 플랫폼을 대상으로 할 수 있어야 한다.

두 번째는 인적 측면이다. 루비 구문 분석기는 C 개발자 그룹인 CRuby 팀에서 유지 관리할 예정이다. 우리의 주요 목표 중 하나가 유지보수성이고 이 사람들이 유지보수를 담당할 사람들이기 때문에, 그들이 가장 익숙한 언어를 사용하는 것이 합리적이라고 생각했다.

## 3. 구조
구문 분석기는 수기 재귀적 하강 구문 분석기(hand-written recursive descent parser)가 될 것이다. 이는 대부분의 주요 프로그래밍 언어의 추세를 따른다. 개발자가 사용하는 상위 10개 언어 중 7/10이 수기 재귀적 하강 구문 분석기이다. 많은 도구가 Bison에서 수기로 전환되었으며, 예를 들어 gcc와 golang도 마찬가지입니다. C#이 이 방식을 채택한 이유도 찾아볼 수 있다.

수기 재귀 하강을 사용하지 않는 언어 중 세 가지 예외는 Python, PHP, Ruby이다. PHP와 Ruby는 현재 Bison을 사용하고 있으며, Python도 최근 PEG 파싱이라는 재귀적 하강을 사용하는 다른 방식으로 전환했다. 이에 대한 자세한 내용은 PEP-617을 참조. https://peps.python.org/pep-0617/ 이 글은 특히 흥미로운데, Ruby에서 과거에 해결해야 했던 것과 같은 방식으로 해결해야 하는 문법의 모호함을 설명한다는 점에서 흥미롭습니다.

아래 코드조각을 예로 들어 설명해보자:
```
with (
	open("a_really_long_foo") as foo,
	open("a_really_long_baz") as baz,
	open("a_really_long_bar") as bar
):
```

이 문맥에서는 열린 괄호 문자가 모호하기 때문에 LL(1) 파싱(그들이 생성한 파서 스타일)을 사용하는 컨텍스트 관리자에게는 이 문법을 표현하는 것이 실제로 불가능하다. 이 문제를 해결하기 위해 문법을 더 모호하게 만든 다음 트리 빌더에서 실제 문법이 적용되도록 했다.

킹스칼리지런던의 교수인 로렌스 트랫은 이 분야에 대한 광범위한 연구를 수행해 왔다. 그의 연구는 실제로 올해 Ruby Kaigi에서 세 번이나 인용되었는데, 루비 파서의 미래 비전, RBS 구문 분석, 그리고 YARP에 대한 강연에서 인용되었다. 그의 연구가 인용된 첫 번째 강연의 두 번째 단락에 그가 쓴 글이 있습니다:
> It is possible to hand-craft error recovery algorithms for a specific language. These generally allow better recovery from errors, but are challenging to create.
> 특정 언어에 대한 오류 복구 알고리즘을 직접 만들 수도 있습니다. 이러한 알고리즘은 일반적으로 오류를 더 잘 복구할 수 있지만 만들기가 어렵습니다.

그런 다음 블로그 게시물에서 LR과 재귀적 하강 구문 분석에 대해 구체적으로 설명한다: https://tratt.net/laurie/blog/2023/why_we_need_to_know_lr_and_recursive_descent_parsing_techniques.html
> Existing languages have often evolved in a manner that makes it difficult, or impossible, to specify an LR grammar. There’s no point in trying to fight this: just use recursive descent parsing.
> 기존 언어는 종종 LR 문법을 지정하기 어렵거나 불가능하게 만드는 방식으로 발전해 왔습니다. 재귀적 하강 구문 분석을 사용하면 됩니다.

> If you need the best possible performance or error recovery, recursive descent parsing is the best choice.
> 최상의 성능 또는 오류 복구가 필요한 경우 재귀적 하강 구문 분석이 최선의 선택입니다.

현실적으로 루비의 문법은 렉서에 상당한 상태가 저장되지 않으면 LR 파서(Bison이 생성하는 종류의 파서)로 정확하게 파싱할 수 없다. 대부분의 프로그래밍 커뮤니티는 자체 구문 분석기에 대해 동일한 결론을 내렸고, 따라서 수작업으로 작성된 재귀적 하강 구문 분석기로 이동했다. 이제 루비도 그렇게 할 때이다.

수기 재귀 하강으로 전환한 마지막 이유는 사실 Matz가 직접 제안한 것이다. 1995년에 출시된 Ruby 0.95 버전에는 작은 할 일 파일이 저장소에 포함되어 있었다. 그 파일에는 몇 안 되는 항목 중 하나가 있었다:
> Hand written parser(recursive decent)


## 4. API/AST
처음에는 혼란을 최소화하기 위해 CRuby와 동일한 구문 트리를 유지하려고 했다. 그러나 런타임 및 도구의 다양한 팀과 논의한 끝에 처음부터 자체적으로 트리를 설계하기로 결정했다. 이 트리는 런타임과 도구 모두에서 작업하기 쉽도록 설계되었다. 또한 향후 유지 관리 및 확장이 용이하도록 설계되었다.

현재 CRuby의 트리에는 소비자와 관련이 없는 정보가 포함되기도 하고 중요한 정보가 누락되기도 한다. 예를 들어, 지역 변수 또는 메서드 호출이 될 수 있는 식별자인 vcall의 개념은 파서에서 우려되는 부분이다. 그러나 이는 구문 분석 시점에 해결된다. 하지만 여전히 Ripper API에 노출되어 있어 그 의미에 대해 혼란을 야기할 수 있다. 이와 대조적으로, 트리에는 linter와 editor에서 사용하는 데 중요한 열 정보가 거의 완전히 누락되어 있다.

트리 재설계와 함께, 저희는 JRuby 및 TruffleRuby 팀과 긴밀히 협력하여 이러한 런타임이 단일 FFI 호출을 수행하고 직렬화된 구문 트리를 반환할 수 있도록 하는 직렬화 API를 개발했다. 직렬화된 구문 트리를 얻으면 구조화된 문서를 통해 Java 클래스를 생성하여 자체 트리와 중간 표현을 구축하는 데 사용할 수 있는 객체로 역직렬화할 수 있다.

트리 재설계는 결국 프로젝트에서 가장 중요한 부분 중 하나가 되었다. 루비에는 이전에 없던 표준화된 구문 트리가 생겼기 때문이다. 표준이 마련됨으로써 커뮤니티는 루비 구조를 논의하는 방법에 대한 집단적 지식과 언어를 구축할 수 있게 되었고, 모든 루비 구현에서 사용할 수 있는 도구를 구축하기 시작할 수 있게 되었다. 앞으로는 도구(Rubocop 및 Syntax Tree 등), 유지관리자, 기여자 간에 더 많은 상호 협업이 이루어질 수 있다.

# Building
## 1. 유지 보수성
처음에 지적한 문제에 집중하기를 원했다. 이 파서를 가능한 한 유지 관리할 수 있도록 만들고 트리의 모든 노드는 예제와 함께 문서화되고 명시적으로 테스트된다.
- https://github.com/ruby/yarp/blob/main/config.yml

마크다운에 넣을 수 있는 모든 디자인에 대한 문서도 여기에서 찾을 수 있다.
- https://github.com/ruby/yarp/tree/main/docs

마지막으로, 유지보수를 최대한 용이하게 하기 위해 풍부한 인라인 주석이 있다.
- https://github.com/ruby/yarp/blob/fc9ee8f566f71ed76a53d58e2b036aeaf39415fd/src/yarp.c#L12068-L12081


## 2. 오차 허용
YARP에는 여러 가지 오류 허용 기능이 기본적으로 포함되어 있으며, 앞으로 몇 달 또는 몇 년 안에 더 많은 기능을 추가할 계획이다.

소스 코드를 편집할 때마다 개발자가 표현식 끝에 도달할 때까지는 거의 항상 구문 오류가 발생한다. 따라서 기본 구문 트리에는 유효한 프로그램에는 있을 법한 토큰과 노드가 누락되는 것이 일반적이다. 따라서 저희가 구축한 첫 번째 오류 허용 기능은 누락된 토큰을 삽입하는 기능이다. 예를 들어, 구문 분석기가 예상했던 곳에서 누락된 end 키워드를 발견하면 자동으로 누락된 토큰을 삽입하고 프로그램 구문 분석을 계속한다.

YARP는 구문 트리에 누락된 노드를 삽입할 수도 있다. 예를 들어, 구문 분석기가 오른쪽이 없는 1 +와 같은 식을 발견하면 오른쪽에 대한 누락된 노드를 삽입하고 프로그램 구문을 계속 분석한다.

또한 YARP가 이해할 수 없는 컨텍스트에서 토큰을 발견하면 해당 토큰을 건너뛰고 구문 분석을 계속하려고 시도한다. 이 기능은 무언가를 복사하여 붙여넣었을 때 실수로 주변 콘텐츠가 몰래 들어오는 경우에 유용하다.

마지막으로, YARP에는 구문 오류가 발생한 문맥을 분석하여 구문 오류를 복구할 수 있는 문맥 기반 복구라는 기술이 포함되어 있다. 이는 Microsoft가 자체 PHP 파서를 만들 때 사용한 방법과 유사하다. 예를 들어, 구문 분석기에
``` ruby
foo.bar(baz, qux1 + qux2 + qux3 +)
```
qux3의 + 호출에 누락된 노드를 삽입한 다음, ) 문자가 인수 목록을 닫는다는 것을 알고 있기 때문에 인수를 구문 분석할 때까지 버블을 발생시킨다. 이 시점에서는 인자에 아무 문제가 없는 것처럼 구문 분석을 계속한다.

이 모든 것을 종합하여 위의 스니펫을 다시 살펴보면 YARP가 언어 서버를 통해 파일의 모든 오류 위치를 나타내기 위해 추가하는 빨간색 밑줄을 볼 수 있다:
![YARP error tolerance](https://railsatscale.com//2023-06-12-rewriting-the-ruby-parser/error-tolerance.png)

앞으로 오류 허용 범위와 관련하여 더 많은 기술을 탐구하고 싶지만, 현재 구문 분석기의 상태에 만족하고 있다.

실제로 작동하는 모습을 보고 싶으시다면 YARP에는 언어 서버와 VSCode 플러그인이 함께 제공되므로 이를 사용해 보실 수 있다. 작동 방식을 설명하는 문서에서 기존의 오류 허용 기능으로 인해 여러 구문 오류가 편집기에 한 번에 표시될 수 있음을 알 수 있다.


## 3. 이식성
YARP는 외부 패키지, 기능 또는 구조에 대한 종속성이 없다. 즉, 완전히 독립적이다. 자체적으로 빌드하여 필요한 모든 도구에서 사용할 수 있다. FFI나 bindgen이 잘 지원되는 언어에서는 구문 분석 함수와 그 반환 구조체에 직접 액세스할 수 있다. 앞으로는 최소한의 노력으로 Rust나 Zig와 같은 언어에서 Ruby 툴링을 빌드할 수 있다는 의미이다.

이러한 지원이 없거나 C 함수를 호출하는 데 비용이 많이 드는 언어의 경우 별도의 직렬화 API를 제공한다. 이 API는 먼저 구문 트리를 내부 구조로 파싱한 다음 호출 언어/도구에서 읽을 수 있는 바이너리 형식으로 직렬화한다. 이 API는 JRuby와 TruffleRuby를 염두에 두고 특별히 설계되었으며, 해당 팀원들이 적극적으로 개발에 도움을 주고 있다.

현재 JRuby는 기능적인 프로토타입을 가지고 있으며, TruffleRuby는 YARP를 병합하여 YARP를 기본 파서로 만들기 위해 활발히 작업하고 있습니다. 이 과정에서 발견한 한 가지 흥미로운 사실은 YARP 역직렬화가 구문 분석보다 약 10배 빠르다는 것이다. 앞으로 트러플루비는 더 빠른 부팅 속도를 위해 표준 라이브러리의 직렬화 버전을 출시할 수 있을 것이다.

C와 직렬화 API가 모두 준비되었으므로 이제 모든 Ruby 구현에서 사용할 수 있는 표준화된 도구를 구축할 수 있으며, 커뮤니티가 Ruby 구문 트리를 논의하는 방법에 대한 공통 언어를 개발하기 시작할 수 있다. 앞으로는 위에서 언급한 모든 도구가 동일한 기본 파서에서 실행될 수 있을 것이다.

기술적인 승리도 매우 기쁘지만, 커뮤니티의 승리도 더욱 기대가 된다. 이제 별도의 구문 분석기를 유지 관리하는 데 시간을 할애해야 했던 우수한 개발자들이 이제 그 시간을 자신의 도구를 특별하게 만드는 데 투자할 수 있게 되었으니까 말이다. 구문 분석기에서 오류가 발생하면 코드를 더 많이 살펴보고, 버그를 수정하고, 새로운 기능을 추가하는 데 도움을 줄 수 있는 사람이 더 많아진다는 뜻이다.

## 4. 성능
구문 분석기가 의미적으로 동등한 구문 트리를 생성할 수 있게 되자, 우리는 성능을 살펴보기 시작했다. 앞서 설명한 대로 트리가 다르고 일반적으로 더 많은 작업을 수행하기 때문에 아직 비교 수치는 없다 (예를 들어, YARP를 사용하는 소비자의 편의를 위해 문자열 노드에 이스케이프되지 않은 버전의 문자열을 제공한다)

지금까지 공유할 수 있는 것은 YARP가 약 4.49초 만에 약 50,000개의 Shopify Ruby 파일을 구문 분석할 수 있으며, 최대 메모리 사용량은 10.94Mb라는 점이다. 말할 필요도 없이 지금까지의 결과에 매우 만족하고 있다.

앞으로는 성능을 최우선으로 고려할 것이며, 이를 위해 여러 가지 최적화를 실험하고 있다. 여기에는 특수 트리 노드를 통한 메모리 사용량 감소, arena 할당을 통한 로컬리티 개선, 더 빠른 해시 조회를 통한 식별자 확인 속도 향상 등이 포함된다.


# Integration
간단한 표현식을 구문 분석할 수 있는 상태에 도달한 후에는 다른 런타임 및 도구와 통합하여 접근 방식과 설계를 검증하고자 했다.
- JRuby와 TruffleRuby 팀은 직렬화 API를 실험하기 시작했고, 저희는 그들과 협력하여 그들의 요구에 충분한지 확인하기 위해 노력했다. 몇 가지 흥미로운 조정(가변 폭 정수 직렬화, 상수 풀 제공 및 기타 최적화)을 통해 각자의 필요에 맞는 형식을 찾았다. 이제 두 런타임 모두 YARP를 런타임에 통합하는 데 상당한 에너지를 투자했으며, 오라클은 YARP TruffleRuby의 메인 파서를 만드는 데 풀타임으로 일하는 사람을 두고 있다.

또한 다른 도구와 협력하여 트리에 정적 분석 및 컴파일을 위한 충분한 메타데이터가 포함되어 있는지 검증했다. Syntax Tree는 Formatter로도 사용할 수 있는 구문 트리 도구 제품군으로, Ripper 대신 YARP를 구문 분석기로 사용하여 실행 중인 실험 브랜치가 있다. 초기 결과에 따르면 Ripper를 YARP로 대체하면 성능이 거의 두 배 가까이 향상되는 경우도 있었다. 또한 오류 위치와 메시지가 정확한지 확인하기 위해 리포지토리 내에서 찾을 수 있는 VSCode 플러그인을 구축했으며, 현재도 계속 작업 중이다.

최근에는 이러한 라이브러리의 소비자들이 새로운 구문 분석기의 이점을 자연스럽게 누릴 수 있도록 하기 위해 구문 분석기와 동일한 구문 트리를 생성하는 실험을 시작했다. 초기 결과는 매우 유망하며 메모리 감소와 속도 증가를 모두 보여준다.

마지막으로, 지난 주에 YARP를 CRuby 리포지토리에 미러링하고, CRuby 내에서 빌드하고, 동일한 테스트 스위트와 지속적인 통합 내에서 실행하는 작업을 시작했다. 이 작업은 YARP를 CRuby에 병합하기 전 마지막 단계이며, 그 결실을 보게 되어 매우 기대가 된다. 이 작업은 앞으로 며칠 내에 완료될 예정이다.

# Path forward
다양한 루비 런타임에 YARP를 통합하는 작업은 계속되고 있으며, 앞으로 더 많은 프로젝트(예: mruby 및 Sorbet)에서 YARP를 시험해볼 수 있게 되어 기대가 크다. 속도, 메모리 소비량, 정확도를 계속 개선해 나갈 것이다. Matz와 CRuby 팀은 올해 12월에 출시될 Ruby 3.3에 YARP를 라이브러리로 제공하기로 합의했기 때문에, 다음 버전의 Ruby에서는 "yarp"를 요구하고 자신만의 구문 트리를 가지고 놀 수 있게 될 것이다. 이 흥미진진한 릴리스가 출시되기 전까지 몇 가지 일이 일어날 것이다:

프로젝트는 보석으로 출시될 가능성이 높으므로 써드파티가 이 프로젝트를 사용하여 작업을 시작하고 자신의 프로젝트에 통합할 수 있다.
- JRuby 및 TruffleRuby 팀과 계속 협력하여 구문 트리의 구조와 직렬화 API가 그들의 요구에 충분히 부합하는지 확인할 것이다. 조만간 YARP를 기본 구문 분석기로 포함하는 언어 런타임이 출시될 수 있기를 바란다.
- 구문 트리는 YARP를 기본 구문 분석기로 채택할 예정이며, 이는 곧 루비-lsp가 모든 이점을 누릴 수 있게 된다는 것을 의미한다.

Ripper와의 호환성을 지속적으로 개선하여 해당 (불안정한) API에 의존하는 라이브러리가 마이그레이션 수단으로 호환성 계층을 사용할 수 있도록 할 것이다.

구문 분석기 자체에 대한 더 많은 작업이 CRuby에 병합되면 계획되어 있다. 여기에는 다음이 포함되지만 이에 국한되지는 않다:
- Forward 스캐닝 오류 허용 - 구문 분석기가 여러 가지 방식으로 해석될 수 있는 구문 오류가 발생하는 경우, 한 가지 접근 방식은 가능한 모든 해석을 토큰 수만큼 앞으로 파싱한 다음 가장 적은 수의 후속 구문 오류가 발생하는 경로를 수락하는 것이다.
- Arena 할당 - 현재 노드는 개별 몰록 호출을 통해 할당되는데, 이는 비용이 많이 들고 조각화/메모리 로컬리티 부족으로 이어질 수 있다.
- 메모리 사용량 - 일반적으로 메모리에서 트리를 비교적 작게 유지했지만, 중복 정보를 제거하거나 일반적으로 메모리에서 트리의 크기를 줄일 수 있는 여지가 항상 존재한다.
- 성능 - 분명히 이것은 방대한 주제이지만, 이제 CRuby와 동등한 수준에 도달했으므로 성능을 개선할 수 있는 방법을 살펴볼 수 있다.

# 연관된 링크
- [현재 복잡한 Parser 구조로 고치지 못하는 에러](https://bugs.ruby-lang.org/issues/19392)
- [YARP 초기 설계](https://docs.google.com/document/d/1x74L_paTxS_h8_OtQjDoLVgxZP6Y96WOJ1LdLNb4BKM/edit#heading=h.6eyajfy04xhw)
- [Python도 최근 PEG 파싱으로 전환(재귀적 하강을 사용하는 다른 방식)](https://peps.python.org/pep-0617/)
- [LR과 재귀적 하강 구문 분석](https://tratt.net/laurie/blog/2023/why_we_need_to_know_lr_and_recursive_descent_parsing_techniques.html)
- YARP 
  - https://github.com/ruby/yarp/blob/main/config.yml
  - https://github.com/ruby/yarp/tree/main/docs
  - https://github.com/ruby/yarp/blob/fc9ee8f566f71ed76a53d58e2b036aeaf39415fd/src/yarp.c#L12068-L12081

# Refs
- https://railsatscale.com//2023-06-12-rewriting-the-ruby-parser/
- https://news.hada.io/topic?id=9395&utm_source=slack&utm_medium=bot&utm_campaign=T028REP4B8D